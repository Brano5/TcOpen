<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="RingBuffer" Id="{e93f5ca1-fc6e-07d3-2964-ffb2913cd835}" SpecialFunc="None">
    <Declaration><![CDATA[//{attribute 'hide_all_locals'}
{attribute 'no_explicit_call' := 'Do not call this POU directly. Please use the provided methods.'} 
FUNCTION_BLOCK RingBuffer

VAR
	_pBuffer				: POINTER TO BYTE;					
	_BufferSize				: UDINT;							
	_pRead					: POINTER TO BYTE;					
	_pWrite					: POINTER TO BYTE;					
	_Size					: UDINT;							
	_IsFull					: BOOL;								
	_IsEmpty				: BOOL;								
	_IsInitialized			: BOOL;								
                                                                
	_ElementSize			: UDINT;							
	_Capacity				: UDINT;							
	_Override				: BOOL;	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Property Name="Capacity" Id="{fc8b9f4e-7cc4-01c2-063f-c8a46fe06421}">
      <Declaration><![CDATA[PROPERTY PUBLIC Capacity : UDINT]]></Declaration>
      <Get Name="Get" Id="{b7a55af0-43ad-04c4-2fec-2b2db131cd93}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Capacity := _Capacity;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Clear" Id="{1c618aee-44a0-069b-3da9-2652b00ef8ad}">
      <Declaration><![CDATA[METHOD PUBLIC Clear : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _IsInitialized AND _pBuffer <> 0 AND _BufferSize > 0 THEN
	Tc2_System.MEMSET(destAddr := _pBuffer, fillByte := 0, n := _BufferSize);
	_pRead := _pBuffer;
	_pWrite := _pBuffer;
	_Size := 0;
	_IsFull := FALSE;
	_IsEmpty := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_exit" Id="{57767b84-d459-0c53-3126-515dd6642342}">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
	bInCopyCode : BOOL; // if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bInCopyCode THEN
	IF _pBuffer <> 0 THEN
		__DELETE(_pBuffer);
		_pRead := 0;
		_pWrite := 0;
		_BufferSize := 0;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{b436c3e4-ce52-0f34-3a9b-7441b811e058}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	Override	: BOOL;
	Capacity	: UDINT;
	ElementSize	: UDINT;
END_VAR

VAR
	bufferSize		: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ElementSize > 0 AND Capacity > 0 THEN
	
	_Override := Override;
	_Capacity := Capacity;
	_ElementSize := ElementSize;

	// calculate buffersize
	bufferSize := ElementSize * Capacity;
	
	// try to get memory
	_pBuffer := __NEW(BYTE, bufferSize);
	
	// check if memory allocation was successful
	IF _pBuffer <> 0 THEN
		_BufferSize := bufferSize;
		_pRead := _pBuffer;
		_pWrite := _pBuffer;
		_IsEmpty := TRUE;
		_IsFull := FALSE;
		_Size := 0;
		_IsInitialized := TRUE;
	ELSE
		// {warning 'todo errorhandling'}
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="IsEmpty" Id="{4cdf8ce3-455d-0966-0239-40b27605f92d}">
      <Declaration><![CDATA[PROPERTY PUBLIC IsEmpty : BOOL]]></Declaration>
      <Get Name="Get" Id="{f80d759f-3197-0b47-042e-9eee3dcb693c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsEmpty := _IsEmpty;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsFull" Id="{75f7838a-4ff5-08e8-1ea7-df2371601cf2}">
      <Declaration><![CDATA[PROPERTY PUBLIC IsFull : BOOL]]></Declaration>
      <Get Name="Get" Id="{6640d17d-d30e-029a-3980-7632bc9477b9}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsFull := _IsFull;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Peek" Id="{d95a608e-9802-06aa-219e-cd9c8faf9720}">
      <Declaration><![CDATA[METHOD PUBLIC Peek : UDINT
VAR_INPUT
	pData			: PVOID;
	Count			: UDINT;
END_VAR
VAR
	pReadTmp		: POINTER TO BYTE;
	pDestCpy		: PVOID;
	nBytesCpy		: UDINT;
	nElmCntToCpy	: UDINT;
	nElmToEnd		: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pReadTmp := _pRead;


IF _IsInitialized AND pData <> 0 AND Count > 0 THEN
	nElmToEnd := (_pBuffer + _BufferSize - pReadTmp) / _ElementSize;
	
	nElmCntToCpy := MIN(Count, _Size);
	pDestCpy := pData;
	
	IF nElmToEnd >= nElmCntToCpy THEN
		// only one copy is needed
		nBytesCpy := nElmCntToCpy * _ElementSize;
		Tc2_System.MEMCPY(destAddr := pDestCpy, srcAddr := pReadTmp, n := nBytesCpy);
		pReadTmp := pReadTmp + nBytesCpy;
		IF pReadTmp > _pBuffer + _BufferSize - 1 THEN
			pReadTmp := _pBuffer;
		END_IF
		
	ELSE
		// 1st copy
		nBytesCpy := nElmToEnd * _ElementSize;
		Tc2_System.MEMCPY(destAddr := pDestCpy, srcAddr := pReadTmp, n := nBytesCpy);
		
		// 2nd copy
		pDestCpy := pData + nBytesCpy;
		pReadTmp := _pBuffer;
		nBytesCpy := (nElmCntToCpy - nElmToEnd) * _ElementSize;
		Tc2_System.MEMCPY(destAddr := pDestCpy, srcAddr := pReadTmp, n := nBytesCpy);

	END_IF
END_IF

Peek := nElmCntToCpy;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Pop" Id="{990c656f-c659-006d-2f28-db9013542ef0}">
      <Declaration><![CDATA[METHOD PUBLIC Pop : UDINT
VAR_INPUT
	pDestination			: PVOID;
	Count			: UDINT;
END_VAR
VAR
	pDestCpy		: PVOID;
	nBytesCpy		: UDINT;
	nElmCntToCpy	: UDINT;
	nElmToEnd		: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _IsInitialized AND pDestination <> 0 AND Count > 0 THEN
	nElmToEnd := (_pBuffer + _BufferSize - _pRead) / _ElementSize;
	
	nElmCntToCpy := MIN(Count, _Size);
	pDestCpy := pDestination;
	
	IF nElmToEnd >= nElmCntToCpy THEN
		// only one copy is needed
		nBytesCpy := nElmCntToCpy * _ElementSize;
		Tc2_System.MEMCPY(destAddr := pDestCpy, srcAddr := _pRead, n := nBytesCpy);
		_pRead := _pRead + nBytesCpy;
		IF _pRead > _pBuffer + _BufferSize - 1 THEN
			_pRead := _pBuffer;
		END_IF
		_Size := _Size - nElmCntToCpy;
		
	ELSE
		// 1st copy
		nBytesCpy := nElmToEnd * _ElementSize;
		Tc2_System.MEMCPY(destAddr := pDestCpy, srcAddr := _pRead, n := nBytesCpy);
		
		// 2nd copy
		pDestCpy := pDestination + nBytesCpy;
		_pRead := _pBuffer;
		nBytesCpy := (nElmCntToCpy - nElmToEnd) * _ElementSize;
		Tc2_System.MEMCPY(destAddr := pDestCpy, srcAddr := _pRead, n := nBytesCpy);
		
		_pRead := _pRead + nBytesCpy;
		
		_Size := _Size - nElmCntToCpy;
	END_IF
END_IF
_IsFull := _Size = _Capacity;
_IsEmpty := _Size = 0;

Pop := nElmCntToCpy;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Push" Id="{d1b9ab8a-8965-03ad-24a1-389482bfbdd5}">
      <Declaration><![CDATA[METHOD PUBLIC Push : UDINT
VAR_INPUT
	pData			: PVOID;
	Count			: UDINT;
END_VAR
VAR
	pSrcCpy			: PVOID;
	nBytesCpy		: UDINT;
	nElmCntToCpy	: UDINT;
	nElmToEnd		: UDINT;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _IsInitialized AND pData <> 0 AND Count > 0 THEN
	nElmToEnd := (_pBuffer + _BufferSize - _pWrite) / _ElementSize;
	
	IF _Capacity - _Size <= Count THEN
		// not enough free space
		IF NOT _Override THEN
			// copy only as much as free space is available
			nElmCntToCpy := _Capacity - _Size;
			pSrcCpy := pData;
			
			IF nElmCntToCpy > 0 THEN
				IF nElmToEnd >= nElmCntToCpy THEN
					// only one copy is needed
					nBytesCpy := nElmCntToCpy * _ElementSize;
					Tc2_System.MEMCPY(destAddr := _pWrite, srcAddr := pSrcCpy, n := nBytesCpy);
					
				ELSE
					// 1st copy
					nBytesCpy := nElmToEnd * _ElementSize;
					Tc2_System.MEMCPY(destAddr := _pWrite, srcAddr := pSrcCpy, n := nBytesCpy);
					
					// 2nd copy
					pSrcCpy := pSrcCpy + nBytesCpy;
					_pWrite := _pBuffer;
					nBytesCpy := (nElmCntToCpy - nElmToEnd) * _ElementSize;
					Tc2_System.MEMCPY(destAddr := _pWrite, srcAddr := pSrcCpy, n := nBytesCpy);
					
				END_IF
			
				_pWrite := _pRead;
				_Size := _Capacity;
			END_IF
		ELSE
			IF _Capacity <= Count THEN
				// number of elements is greater than capacity -> just copy the last ones
				nElmCntToCpy := _Capacity;
				pSrcCpy := pData + (Count - _Capacity) * _ElementSize;
				nBytesCpy := _ElementSize * nElmCntToCpy;
				Tc2_System.MEMCPY(destAddr := _pBuffer, srcAddr := pSrcCpy, n := nBytesCpy);
				_pRead := _pBuffer;
				_pWrite := _pBuffer;
				_Size := _Capacity;
			ELSE
				nElmCntToCpy := Count;
				pSrcCpy := pData;
				
				IF nElmToEnd >= nElmCntToCpy THEN
					// only one copy is needed
					nBytesCpy := nElmCntToCpy * _ElementSize;
					Tc2_System.MEMCPY(destAddr := _pWrite, srcAddr := pSrcCpy, n := nBytesCpy);
					_pWrite := _pWrite + nBytesCpy;
					IF _pWrite > _pBuffer + _BufferSize - 1 THEN
						_pWrite := _pBuffer;
					END_IF
					_pRead := _pWrite;
					
				ELSE
					// 1st copy
					nBytesCpy := nElmToEnd * _ElementSize;
					Tc2_System.MEMCPY(destAddr := _pWrite, srcAddr := pSrcCpy, n := nBytesCpy);
					
					// 2nd copy
					pSrcCpy := pSrcCpy + nBytesCpy;
					_pWrite := _pBuffer;
					nBytesCpy := (nElmCntToCpy - nElmToEnd) * _ElementSize;
					Tc2_System.MEMCPY(destAddr := _pWrite, srcAddr := pSrcCpy, n := nBytesCpy);
					
					_pWrite := _pWrite + nBytesCpy;
					_pRead := _pWrite;
				END_IF
				
				_Size := _Capacity;
				END_IF
		END_IF
	ELSE
		nElmCntToCpy := Count;
		pSrcCpy := pData;
		
		IF nElmToEnd >= nElmCntToCpy THEN
			// only one copy is needed
			nBytesCpy := nElmCntToCpy * _ElementSize;
			Tc2_System.MEMCPY(destAddr := _pWrite, srcAddr := pSrcCpy, n := nBytesCpy);
			_pWrite := _pWrite + nBytesCpy;
			IF _pWrite > _pBuffer + _BufferSize - 1 THEN
				_pWrite := _pBuffer;
			END_IF
			
		ELSE
			// 1st copy
			nBytesCpy := nElmToEnd * _ElementSize;
			Tc2_System.MEMCPY(destAddr := _pWrite, srcAddr := pSrcCpy, n := nBytesCpy);
			
			// 2nd copy
			pSrcCpy := pSrcCpy + nBytesCpy;
			_pWrite := _pBuffer;
			nBytesCpy := (nElmCntToCpy - nElmToEnd) * _ElementSize;
			Tc2_System.MEMCPY(destAddr := _pWrite, srcAddr := pSrcCpy, n := nBytesCpy);
			
			_pWrite := _pWrite + nBytesCpy;
		END_IF
		
		_Size := _Size + nElmCntToCpy;
	END_IF
END_IF

_IsEmpty := _Size = 0;
_IsFull := _Size = _Capacity;

Push := nElmCntToCpy;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Size" Id="{457402ed-47fd-075e-1d30-db8ada1e1433}">
      <Declaration><![CDATA[PROPERTY PUBLIC Size : UDINT]]></Declaration>
      <Get Name="Get" Id="{b9191cdf-6294-012b-11bc-6ec26709d6e6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Size := _Size;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <LineIds Name="RingBuffer">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.Capacity.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.Clear">
      <LineId Id="3" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.FB_exit">
      <LineId Id="3" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.FB_init">
      <LineId Id="51" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.IsEmpty.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.IsFull.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.Peek">
      <LineId Id="100" Count="31" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.Pop">
      <LineId Id="106" Count="34" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.Push">
      <LineId Id="255" Count="107" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RingBuffer.Size.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>